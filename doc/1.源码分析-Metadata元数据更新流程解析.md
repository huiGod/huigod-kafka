[TOC]

# Metadata元数据组件

kafka中的Metadata类表示元数据信息，维护所有集群信息，包括topic信息、topic下的partition信息、partition所在的broker节点信息等

```java
public final class Metadata {

    private static final Logger log = LoggerFactory.getLogger(Metadata.class);

    //元数据刷新间隔最短时间，避免频繁拉取。默认100ms
    private final long refreshBackoffMs;
    //元数据可以被持有的最长时间。默认60min
    private final long metadataExpireMs;
    //版本号
    private int version;
    //最近刷新时间
    private long lastRefreshMs;
    //最近成功刷新时间
    private long lastSuccessfulRefreshMs;
    //表示集群中所有的节点、topic、分区信息
    private Cluster cluster;
    //是否需要更新元数据标识
    private boolean needUpdate;
    //集群下的所有topic集合
    private final Set<String> topics;
    //监听器
    private final List<Listener> listeners;
    private boolean needMetadataForAllTopics;
    ...
}
```

Metadata一定会被多个客户端并发使用，但是这里的字段都没有使用并发安全的数据结构，是因为暴露出去的方法都添加了synchronized来保证线程安全

例如返回元数据方法：

```java
    public synchronized Cluster fetch() {
        return this.cluster;
    }
```

# 客户端触发Metedata更新的时机

客户端在发送消息，未查询到指定topic元数据信息时，需要去请求最新元数据，代码片段如下：

```java
//循环从 broker 拉取最新 topic 元数据，直到成功获取元数据或者异常抛错
while (metadata.fetch().partitionsForTopic(topic) == null) {
    log.trace("Requesting metadata update for topic {}.", topic);
    //更新需要刷新元数据的标识，并返回当前版本号
    int version = metadata.requestUpdate();
    //唤醒 sender 线程去发送请求到broker拉取topic 的元数据
    sender.wakeup();
    //阻塞等待元数据的更新
    metadata.awaitUpdate(version, remainingWaitMs);
    //判断是否超时
    long elapsed = time.milliseconds() - begin;
    if (elapsed >= maxWaitMs)
        //抛出超时异常
        throw new TimeoutException("Failed to update metadata after " + maxWaitMs + " ms.");
    //判断是否是未授权访问的 topic
    if (metadata.fetch().unauthorizedTopics().contains(topic))
        //抛出权限异常
        throw new TopicAuthorizationException(topic);
    remainingWaitMs = maxWaitMs - elapsed;
}
```

首先会修改Metadata中的needUpdate标识为true，客户端会依赖该标识来决定是否发送请求给Broker获取最新元数据

```java
public synchronized int requestUpdate() {
    this.needUpdate = true;
    return this.version;
}
```

# Sender线程发送请求更新元数据

Sender是后台线程，负责发送请求到kafka集群节点，在Sender每次发送请求给broker的时候，会依据needUpdate标识和上一次更新时间来判断是否需要刷新元数据，如果需要则发送METADATA类型请求到broker

```java
@Override
public long maybeUpdate(long now) {
    // should we update our metadata?
    long timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);
    long timeToNextReconnectAttempt = Math.max(this.lastNoNodeAvailableMs + metadata.refreshBackoff() - now, 0);
    long waitForMetadataFetch = this.metadataFetchInProgress ? Integer.MAX_VALUE : 0;
    // if there is no node available to connect, back off refreshing metadata
    long metadataTimeout = Math.max(Math.max(timeToNextMetadataUpdate, timeToNextReconnectAttempt),
            waitForMetadataFetch);

    if (metadataTimeout == 0) {
        // Beware that the behavior of this method and the computation of timeouts for poll() are
        // highly dependent on the behavior of leastLoadedNode.
        Node node = leastLoadedNode(now);
        //发送消息到 broker 获取元数据
        maybeUpdate(now, node);
    }

    return metadataTimeout;
}
```

封装请求元数据类型请求，后续发送给broker

```java
private void maybeUpdate(long now, Node node) {
    if (node == null) {
        log.debug("Give up sending metadata request since no node is available");
        // mark the timestamp for no node available to connect
        this.lastNoNodeAvailableMs = now;
        return;
    }
    String nodeConnectionId = node.idString();

    if (canSendRequest(nodeConnectionId)) {
        this.metadataFetchInProgress = true;
        //封装请求，发送到 broker拉取元数据
        MetadataRequest metadataRequest;
        if (metadata.needMetadataForAllTopics())
            metadataRequest = MetadataRequest.allTopics();
        else
            metadataRequest = new MetadataRequest(new ArrayList<>(metadata.topics()));
        ClientRequest clientRequest = request(now, nodeConnectionId, metadataRequest);
        log.debug("Sending metadata request {} to node {}", metadataRequest, node.id());
        //底层发送逻辑
        doSend(clientRequest, now);
    } else if (connectionStates.canConnect(nodeConnectionId, now)) {
        // we don't have a connection to this node right now, make one
        log.debug("Initialize connection to node {} for sending metadata request", node.id());
        initiateConnect(node, now);
        // If initiateConnect failed immediately, this node will be put into blackout and we
        // should allow immediately retrying in case there is another candidate node. If it
        // is still connecting, the worst case is that we end up setting a longer timeout
        // on the next round and then wait for the response.
    } else { // connected, but can't send more OR connecting
        // In either case, we just need to wait for a network event to let us know the selected
        // connection might be usable again.
        this.lastNoNodeAvailableMs = now;
    }
}
```

# 客户端阻塞等待元数据的更新

客户端会阻塞等待元数据的更新，直到Metadata成功更新后的版本号大于指定版本号，或者超时抛出异常

```java
public synchronized void awaitUpdate(final int lastVersion, final long maxWaitMs) throws InterruptedException {
    if (maxWaitMs < 0) {
        throw new IllegalArgumentException("Max time to wait for metadata updates should not be < 0 milli seconds");
    }
    long begin = System.currentTimeMillis();
    long remainingWaitMs = maxWaitMs;
    //如果集群version大于传入的version，说明元数据有更新
    while (this.version <= lastVersion) {
        if (remainingWaitMs != 0)
            //阻塞指定时间等待。这里会wait释放锁
            //sender 线程在remainingWaitMs时间内把 topic 元数据加载到了，然后缓存到 Metadata 里去，
            //更新 version 版本号，此时一定会唤醒这里的阻塞，让主线程直接返回
            wait(remainingWaitMs);
        //被唤醒后判断是否超时
        long elapsed = System.currentTimeMillis() - begin;
        if (elapsed >= maxWaitMs)
            throw new TimeoutException("Failed to update metadata after " + maxWaitMs + " ms.");
        //计算剩余可以等待时间
        remainingWaitMs = maxWaitMs - elapsed;
    }
}
```

# 请求响应结果解析为元数据

在客户端处理响应数据时，如果是元数据类型的响应，则解析响应结果并更新为元数据

```java
@Override
public boolean maybeHandleCompletedReceive(ClientRequest req, long now, Struct body) {
    short apiKey = req.request().header().apiKey();
    if (apiKey == ApiKeys.METADATA.id && req.isInitiatedByNetworkClient()) {
        //执行回调
        handleResponse(req.request().header(), body, now);
        return true;
    }
    return false;
}

private void handleResponse(RequestHeader header, Struct body, long now) {
    this.metadataFetchInProgress = false;
    MetadataResponse response = new MetadataResponse(body);
    Cluster cluster = response.cluster();
    // check if any topics metadata failed to get updated
    Map<String, Errors> errors = response.errors();
    if (!errors.isEmpty())
        log.warn("Error while fetching metadata with correlation id {} : {}", header.correlationId(), errors);

    // don't update the cluster if there are no valid nodes...the topic we want may still be in the process of being
    // created which means we will get errors and no nodes until it exists
    if (cluster.nodes().size() > 0) {
        //更新 cluster 集群数据
        this.metadata.update(cluster, now);
    } else {
        log.trace("Ignoring empty metadata response with correlation id {}.", header.correlationId());
        this.metadata.failedUpdate(now);
    }
}
```

Metadata.update会执行更新元数据操作

```java
public synchronized void update(Cluster cluster, long now) {
    //更新标识位
    this.needUpdate = false;
    //更新最新刷新元数据时间
    this.lastRefreshMs = now;
    //更新上一次成功刷新元数据事件
    this.lastSuccessfulRefreshMs = now;
    //更新版本号
    this.version += 1;

    //执行监听器
    for (Listener listener: listeners)
        listener.onMetadataUpdate(cluster);

    // Do this after notifying listeners as subscribed topics' list can be changed by listeners
    //是否需要一次性把所有的 topic 元数据都获取，默认是 false
    this.cluster = this.needMetadataForAllTopics ? getClusterForCurrentTopics(cluster) : cluster;
    //更新完最新元数据后，唤醒其他等待获取元数据的线程
    notifyAll();
    log.debug("Updated cluster metadata version {} to {}", this.version, this.cluster);
}
```

# 流程图

![01_kafka_Metadata元数据](d:\user\01405970\Pictures\01_kafka_Metadata元数据.png)